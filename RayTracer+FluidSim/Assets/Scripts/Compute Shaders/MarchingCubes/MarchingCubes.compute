#pragma kernel CalcGridDensities // 0
#pragma kernel FindSurface // 1
#pragma kernel GenerateFluidMesh // 2
#pragma kernel DeleteFluidMesh // 3
#pragma kernel TransferFluidMesh // 4

#include "MarchingCubesResources.hlsl"

// Marching squares settings
const float CellSize;
const float DensityRadius;
const float Threshold;
const uint4 NumCells;

// Mesh generation settings
const int FluidMeshLength;
const int ReservedTrisNum;
const int ReservedVerticesNum;

const float DistanceMultiplier;
const float DensityMultiplier;

RWStructuredBuffer<int2> SpatialLookup; // [NumObjects](sphereIndex, CellKey)
RWStructuredBuffer<int> StartIndices;
RWStructuredBuffer<float3> Points;

AppendStructuredBuffer<MCTri> FluidTriMeshAPPEND;
ConsumeStructuredBuffer<MCTri> FluidTriMeshCONSUME;

RWStructuredBuffer<Triangle> Triangles;
RWStructuredBuffer<Vertex2> Vertices;

RWTexture3D<float> GridDensities;
RWTexture3D<float> SurfaceCells;

bool ValidCell(int3 cell)
{
    return cell.x >= 0 && cell.x < (int)NumCells.x &&
           cell.y >= 0 && cell.y < (int)NumCells.y &&
           cell.z >= 0 && cell.z < (int)NumCells.z;
}

int GetCellKey(int3 cell)
{
    return cell.x + cell.y * NumCells.x + cell.z * NumCells.w;
}

NearInfo GetNearDstCheap(float3 pos)
{
    int3 cell = int3(pos / CellSize);
    int cellKey = GetCellKey(cell);
    int startIndex = StartIndices[cellKey];
 
    NearInfo nearInfo;
    nearInfo.materialIndex = -1;
    float nearDstSqr = FLT_MAX;
    int index = startIndex;
    while (cellKey == SpatialLookup[index].y)
    {
        int pointIndex = SpatialLookup[index].x;
        float3 point2 = Points[pointIndex];
 
        float3 dst = pos - point2;
        float dstSqr = dot2(dst);
        nearDstSqr = min(nearDstSqr, dstSqr);
 
        // --- Increment index each iteration - Cell particle search algorithm ---
 
        index += 1;
    }
 
    nearInfo.val = sqrt(nearDstSqr);
 
    return nearInfo;
}
 
NearInfo GetNearDst(float3 pos, int radius)
{
    int3 cell = int3(pos / CellSize);
 
    float radiusSqr = sqr(radius);
    NearInfo nearInfo;
    nearInfo.materialIndex = -1;
    float nearDstSqr = FLT_MAX;
    for (int x = -radius; x <= radius; x++)
    {
        for (int y = -radius; y <= radius; y++)
        {
            for (int z = -radius; z <= radius; z++)
            {
                int3 curCell = cell + int3(x, y, z);
 
                if (!ValidCell(curCell)) continue;
 
                int cellKey = GetCellKey(curCell);
                int startIndex = StartIndices[cellKey];
 
                int index = startIndex;
                while (cellKey == SpatialLookup[index].y)
                {
                    int pointIndex = SpatialLookup[index].x;
                    float3 point2 = Points[pointIndex];
           
                    float3 dst = pos - point2;
                    float dstSqr = dot2(dst);

                    nearDstSqr = min(nearDstSqr, dstSqr);
           
                    // --- Increment index each iteration - Cell particle search algorithm ---
           
                    index++;
                }
            }
        }
    }
 
    nearInfo.val = max(1 - sqrt(nearDstSqr) * DistanceMultiplier, 0);
 
    return nearInfo;
}
 
NearInfo GetNearDensity(float3 pos, int radius)
{
    int3 cell = int3(pos / CellSize);

    float radiusSqr = sqr(radius);
    NearInfo nearInfo;
    nearInfo.materialIndex = -1;
    float totDensity = 0.0;
    for (int x = -radius; x <= radius; x++)
    {
        for (int y = -radius; y <= radius; y++)
        {
            for (int z = -radius; z <= radius; z++)
            {
                int3 curCell = cell + int3(x, y, z);
 
                if (!ValidCell(curCell)) continue;
 
                int cellKey = GetCellKey(curCell);
                int startIndex = StartIndices[cellKey];
 
                int index = startIndex;
                while (cellKey == SpatialLookup[index].y)
                {
                    int pointIndex = SpatialLookup[index].x;
                    float3 point2 = Points[pointIndex];
           
                    float3 dst = pos - point2;
                    float dstSqr = dot2(dst);
 
                    if (dstSqr > radiusSqr) { index++; continue; }
 
                    totDensity += MSDensityKernel(sqrt(dstSqr), radius);
           
                    // --- Increment index each iteration - Cell particle search algorithm ---
           
                    index ++;
                }
            }
        }
    }
 
    nearInfo.val = max(totDensity * DensityMultiplier, 0);
 
    return nearInfo;
}

// Similar to a density map, but cheaper
[numthreads(TN_MC,TN_MC,TN_MC)]
void CalcGridDensities (uint3 mcCell : SV_DispatchThreadID)
{
    if (!ValidCell(mcCell)) return;

    float3 pos = mcCell * CellSize;
    NearInfo nearInfo = GetNearDst(pos, DensityRadius);

    GridDensities[mcCell] = nearInfo.val;
}

[numthreads(TN_MC,TN_MC,TN_MC)]
void FindSurface (uint3 baseCell : SV_DispatchThreadID)
{
    if (!ValidCell(baseCell+1)) return;

    bool c0_0_0 = GridDensities[baseCell] < Threshold;
    bool c1_0_0 = GridDensities[baseCell + uint3(1,0,0)] < Threshold;
    bool c0_1_0 = GridDensities[baseCell + uint3(1,0,1)] < Threshold;
    bool c1_1_0 = GridDensities[baseCell + uint3(0,0,1)] < Threshold;
    bool c0_0_1 = GridDensities[baseCell + uint3(0,1,0)] < Threshold;
    bool c1_0_1 = GridDensities[baseCell + uint3(1,1,0)] < Threshold;
    bool c0_1_1 = GridDensities[baseCell + uint3(1,1,1)] < Threshold;
    bool c1_1_1 = GridDensities[baseCell + uint3(0,1,1)] < Threshold;

    bool isSurfaceCell = (c0_0_0 || c1_0_0 || c0_1_0 || c1_1_0 || c0_0_1 || c1_0_1 || c0_1_1 || c1_1_1)
                          && !(c0_0_0 && c1_0_0 && c0_1_0 && c1_1_0 && c0_0_1 && c1_0_1 && c0_1_1 && c1_1_1);

    SurfaceCells[baseCell] = isSurfaceCell ? 1 : 0;
}

float3 interpolateVerts(float d1, float d2, float3 v1, float3 v2, float Threshold)
{
    float t = saturate((Threshold - d1) / (d2 - d1));
    
    return lerp(v1, v2, t);
}

[numthreads(TN_MC,TN_MC,TN_MC)]
void GenerateFluidMesh (uint3 baseCell : SV_DispatchThreadID)
{
    if (!ValidCell(baseCell+1) || SurfaceCells[baseCell] != 1) return;

    uint3 localPositions[8] = {
        baseCell,
        baseCell + uint3(1,0,0),
        baseCell + uint3(1,0,1),
        baseCell + uint3(0,0,1),
        baseCell + uint3(0,1,0),
        baseCell + uint3(1,1,0),
        baseCell + uint3(1,1,1),
        baseCell + uint3(0,1,1)
    };

    float densities[8] = {
        GridDensities[localPositions[0]],
        GridDensities[localPositions[1]],
        GridDensities[localPositions[2]],
        GridDensities[localPositions[3]],
        GridDensities[localPositions[4]],
        GridDensities[localPositions[5]],
        GridDensities[localPositions[6]],
        GridDensities[localPositions[7]]
    };

    // Calculate unique index for each cube configuration.
    // There are 256 possible values
    // A value of 0 means cube is entirely inside surface; 255 entirely outside.
    // The value is used to look up the edge table, which indicates which edges of the cube are cut by the isosurface.
    int cubeIndex = 0;
    if (densities[0] > Threshold) cubeIndex |= 1;
    if (densities[1] > Threshold) cubeIndex |= 2;
    if (densities[2] > Threshold) cubeIndex |= 4;
    if (densities[3] > Threshold) cubeIndex |= 8;
    if (densities[4] > Threshold) cubeIndex |= 16;
    if (densities[5] > Threshold) cubeIndex |= 32;
    if (densities[6] > Threshold) cubeIndex |= 64;
    if (densities[7] > Threshold) cubeIndex |= 128;

    // Create triangles for current cube configuration
    for (int i = 0; triangulation[cubeIndex][i] != -1; i +=3)
    {
        // Get indices of corner points A and B for each of the three edges
        // of the cube that need to be joined to form the triangle.
        int a0 = cornerIndexAFromEdge[triangulation[cubeIndex][i]];
        int b0 = cornerIndexBFromEdge[triangulation[cubeIndex][i]];

        int a1 = cornerIndexAFromEdge[triangulation[cubeIndex][i+1]];
        int b1 = cornerIndexBFromEdge[triangulation[cubeIndex][i+1]];

        int a2 = cornerIndexAFromEdge[triangulation[cubeIndex][i+2]];
        int b2 = cornerIndexBFromEdge[triangulation[cubeIndex][i+2]];

        MCTri tri;
        tri.vertex0 = interpolateVerts(densities[a0], densities[b0], localPositions[a0], localPositions[b0], Threshold);
        tri.vertex1 = interpolateVerts(densities[a1], densities[b1], localPositions[a1], localPositions[b1], Threshold);
        tri.vertex2 = interpolateVerts(densities[a2], densities[b2], localPositions[a2], localPositions[b2], Threshold);

        // Transform to render world space
        tri.vertex0 *= CellSize;
        tri.vertex1 *= CellSize;
        tri.vertex2 *= CellSize;

        FluidTriMeshAPPEND.Append(tri);
    }
}

[numthreads(TN_MC2,1,1)]
void DeleteFluidMesh (uint3 id : SV_DispatchThreadID)
{
    Triangles[id.x + ReservedTrisNum].vertex0Index = -1;
}

float GetMCTriArea(MCTri tri)
{
    float3 ab = tri.vertex1 - tri.vertex0;
    float3 ac = tri.vertex2 - tri.vertex0;

    float3 crossProduct = cross(ab, ac);
    float area = length(crossProduct) * 0.5;
    return area;
}

float3 GetPlaneNormal (MCTri tri)
{
    float3 ab = tri.vertex1 - tri.vertex0;
    float3 ac = tri.vertex2 - tri.vertex0;

    return normalize(cross(ab, ac));
}

// COMBINE DELETE AND TRANSFER KERNELS
[numthreads(TN_MC2,1,1)]
void TransferFluidMesh (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= FluidMeshLength) return;
    uint i = id.x;

    MCTri mcTri = FluidTriMeshCONSUME.Consume();

    uint vertexBaseIndex = 3 * i + ReservedVerticesNum;

    Vertices[vertexBaseIndex] = InitVertex(mcTri.vertex0, float2(-1, -1));
    Vertices[vertexBaseIndex + 1] = InitVertex(mcTri.vertex1, float2(-1, -1));
    Vertices[vertexBaseIndex + 2] = InitVertex(mcTri.vertex2, float2(-1, -1));

    float3 localNormal = GetPlaneNormal(mcTri);
    float area = GetMCTriArea(mcTri);

    Triangles[i + ReservedTrisNum] = InitTriangle(vertexBaseIndex, vertexBaseIndex + 1, vertexBaseIndex + 2, localNormal, area);
}