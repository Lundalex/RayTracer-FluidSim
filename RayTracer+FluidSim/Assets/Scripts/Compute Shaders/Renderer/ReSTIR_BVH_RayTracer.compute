#pragma kernel InitialTrace // 0
#pragma kernel SpatialReusePass // 1
#pragma kernel TransferToOriginal // 2
#pragma kernel TemporalReuse // 3
#pragma kernel TraceRays // 4

#pragma multi_compile _ VIS_REUSE
#pragma multi_compile _ WEIGHT_RECALC
#pragma multi_compile _ BRDF

#include "RendererResources.hlsl"
#include "BRDF.hlsl"

// Constants
const uint TrianglesNum;
const uint BVsNum;
const uint MaxBVHDepth;
const uint SceneBVHStartIndex;
const uint SceneObjectsNum;
const float ScatterProbability;
 
// Render quality settings
const uint MaxBounceCount;
 
// View settings
const int2 Resolution;
const float2 ViewSpaceDims;
const float DefocusStrength;
const float FocalPlaneFactor;
 
// Camera orientation and transform
const float3 WorldSpaceCameraPos;
const float3 LastWorldSpaceCameraPos;
const float3x3 CameraTransform;
const float3x3 LastCameraTransformInverse;
 
// Per frame
const uint FrameRand; // "random" value from 0 to 999999, gets reset each frame
const uint FrameCount; // Each frame: FrameCount++
 
// Debug
const int2 DebugDataMaxValues;
 
// ReSTIR - Reservoir sample quality
const uint SceneObjectReservoirTestsNum;
const uint TriReservoirTestsNum;
 
// ReSTIR - Spatial reuse
const bool ReuseBufferCycle;
const int MaxOffset;
const uint TemporalCandidatesNum;
const float SpatialHitPointDiffThreshold;
const float SpatialNormalsAngleThreshold;
const float SpatialBRDFThreshold;
 
// ReSTIR - Temporal reuse
const float TemporalReuseWeight;
const float PixelMovementThreshold;
const float TemporalPrecisionThreshold;

// ReSTIR - Visibility reuse
const float VisibilityReuseThreshold;

// ReSTIR - Other
const uint EmittingObjectsNum;
const float TotArea;
 
RWStructuredBuffer<HitInfo> HitInfos;
RWStructuredBuffer<CandidateReservoir> Candidates; // float4(dir, weight)
RWStructuredBuffer<CandidateReservoir> CandidatesB; // buffer double to "Candidates". Used for spatio-temporal reuse
RWStructuredBuffer<CandidateReservoir> TemporalFrameBuffer;

StructuredBuffer<BV> BVs;
StructuredBuffer<SceneObject> SceneObjects;
StructuredBuffer<LightObject> LightObjects;
StructuredBuffer<Material2> Materials;

StructuredBuffer<Triangle> Triangles;
StructuredBuffer<Vertex2> Vertices;
 
// RW textures
RWTexture2D<float4> Result;
RWTexture2D<float> DepthBuffer;
RWTexture2D<float3> NormalsBuffer;
RWTexture2D<float4> DebugOverlay;
RWTexture2D<float3> RayHitPointsA; // double buffer A
RWTexture2D<float3> RayHitPointsB; // double buffer B

Texture2D<float4> TextureAtlas;
Texture2D<float4> EnvironmentMap; // float4(r, g, b, brightness)
const float2 TextureAtlasDims;
const float2 EnvironmentMapTexDims;

// Fluid mesh test
Texture3D<int2> SurfaceCellsLookup;
Texture3D<int> SurfaceCells;
const uint3 TextureMM1Dims;
const uint StaticVerticesNum;
const uint StaticTrisNum;
const uint MipmapMaxDepth;

// Fluid world transform & grid
const float3 FluidDims;
const float3 FluidPos;
const uint3 NumCells;

float3 SampleTexture(float2 uv, uint2 texLoc, uint2 texDims, Texture2D tex)
{
    uint2 texelCoord = texLoc + (uint2)(uv * float2(texDims.x, texDims.y));
    float4 col = tex.Load(int3(texelCoord, 0));
 
    return col.xyz;
}

float3 SampleEnvironmentMap(float3 dir)
{
    dir = -dir;

    // Compute spherical coordinates
    float theta = atan2(dir.z, dir.x); // longitude
    float phi = asin(dir.y);           // latitude
    
    float u = (theta / (2.0 * PI)) + 0.5;
    float v = 0.5 - (phi / PI);
    float2 uv = float2(u, v);

    float3 col = SampleTexture(uv, int2(0, 0), EnvironmentMapTexDims, EnvironmentMap);

    return col;
}
 
TriHitInfo RayTriangleIntersect(Ray ray, Triangle tri)
{
    Vertex2 v0 = Vertices[tri.vertex0Index];
    Vertex2 v1 = Vertices[tri.vertex1Index];
    Vertex2 v2 = Vertices[tri.vertex2Index];

    float3 edgeAB = v1.pos - v0.pos;
    float3 edgeAC = v2.pos - v0.pos;
    float3 normalVector = cross(edgeAB, edgeAC);
    float3 ao = ray.pos - v0.pos;
    float3 dao = cross(ao, ray.dir);
 
    float determinant = -dot(ray.dir, normalVector);
    float invDet = 1 / determinant;
 
    // Calculate dst to tri & barycentric coordinates of intersection point
    float dst = dot(ao, normalVector) * invDet;
    float u = dot(edgeAC, dao) * invDet;
    float v = -dot(edgeAB, dao) * invDet;
    float w = 1 - u - v;
 
    // Initialize tri hit info
    TriHitInfo triHitInfo;
    triHitInfo.didHit = determinant >= 1E-8 && dst >= 0 && u >= 0 && v >= 0 && w >= 0;
    triHitInfo.uv = triHitInfo.didHit ? v0.uv * w + v1.uv * u + v2.uv * v : float2(0, 0);
    triHitInfo.dst = dst;
    return triHitInfo;
}
 
float RayBVIntersect(Ray ray, BV bv)
{
    float3 tMin = (bv.min - ray.pos) * ray.invDir;
    float3 tMax = (bv.max - ray.pos) * ray.invDir;
    float3 t1 = min(tMin, tMax);
    float3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
 
    bool didHit = tFar >= tNear && tFar > 0;
    float dst = didHit ? tNear > 0 ? tNear : 0 : 1.#INF;
 
    return dst;
};

void TestTriangles(inout HitInfo hitInfo, inout DebugData debugData, Ray ray, uint startIndex, uint endIndex)
{
    for (uint triIndex = startIndex; triIndex < endIndex; triIndex++)
    {
        Triangle tri = Triangles[triIndex];
        if (dot(tri.localNormal, ray.dir) <= 0)
        {
            TriHitInfo triHitInfo = RayTriangleIntersect(ray, tri);
            debugData.triChecks++;
        
            if (triHitInfo.didHit && triHitInfo.dst < hitInfo.dst)
            {
                hitInfo.dst = triHitInfo.dst;
                hitInfo.uv = triHitInfo.uv;
                hitInfo.normal = tri.localNormal;
            }
        }
    }
}
 
void TraverseTrisBVH(inout HitInfo hitInfo, inout DebugData debugData, Ray ray, uint bvStartIndex)
{
    uint bvStack[MAX_BVH_DEPTH + 1];
    uint stackPointer = 0;
    bvStack[stackPointer++] = bvStartIndex;
 
    while (stackPointer > 0)
    {
        BV bv = BVs[bvStack[--stackPointer]];
 
        bool isLeaf = bv.indexA >= 0;
        bv.indexA = abs(bv.indexA);
        bv.indexB = abs(bv.indexB);
        
        if (isLeaf)
        {
            TestTriangles(hitInfo, debugData, ray, bv.indexA, bv.indexA + bv.indexB);
        }
        else
        {
            // Check child BV intersections
            BV bvA = BVs[bv.indexA];
            BV bvB = BVs[bv.indexB];
            float dstA = RayBVIntersect(ray, bvA);
            float dstB = RayBVIntersect(ray, bvB);
            debugData.bvChecks += 2;
 
            // Push the nearest BV last, to avaluate it first
            if (dstA < dstB)
            {
                if (dstB < hitInfo.dst) bvStack[stackPointer++] = bv.indexB;
                if (dstA < hitInfo.dst) bvStack[stackPointer++] = bv.indexA;
            }
            else
            {
                if (dstA < hitInfo.dst) bvStack[stackPointer++] = bv.indexA;
                if (dstB < hitInfo.dst) bvStack[stackPointer++] = bv.indexB;
            }
        }
    }
}
 
void TraverseSceneBVH(inout HitInfo hitInfo, inout DebugData debugData, Ray ray)
{
    uint bvStack[MAX_BVH_DEPTH + 1];
    uint stackPointer = 0;
    bvStack[stackPointer++] = SceneBVHStartIndex;
 
    while (stackPointer > 0)
    {
        BV bv = BVs[bvStack[--stackPointer]];
 
        bool isLeaf = bv.indexA >= 0;
        bv.indexA = abs(bv.indexA);
        bv.indexB = abs(bv.indexB);
        
        if (isLeaf)
        {
            for (int sceneObjectIndex = bv.indexA; sceneObjectIndex < bv.indexA + bv.indexB; sceneObjectIndex++)
            {
                SceneObject sceneObject = SceneObjects[sceneObjectIndex];
 
                Ray localRay;
                localRay.pos = mul(sceneObject.worldToLocalMatrix, float4(ray.pos, 1)).xyz;
                localRay.dir = mul(sceneObject.worldToLocalMatrix, float4(ray.dir, 0)).xyz;
                localRay.invDir = 1 / localRay.dir;
        
                HitInfo localHitInfo = InitHitInfo();
        
                TraverseTrisBVH(localHitInfo, debugData, localRay, sceneObject.bvStartIndex);
                
                Material2 material = Materials[sceneObject.materialIndex];
                if (all(material.normalsTexLoc != -1)) localHitInfo.normal = SampleTexture(localHitInfo.uv, material.normalsTexLoc, material.normalsTexDims, TextureAtlas) * 2 - 1;

                if (localHitInfo.dst < hitInfo.dst)
                {
                    hitInfo.dst = localHitInfo.dst;
                    hitInfo.normal = normalize(mul(sceneObject.localToWorldMatrix, float4(localHitInfo.normal, 0)).xyz);
                    hitInfo.hitPoint = ray.pos + ray.dir * localHitInfo.dst;
                    hitInfo.uv = localHitInfo.uv;
                    hitInfo.materialIndex = sceneObject.materialIndex;
                }
            }
        }
        else
        {
            // Check child BV intersections
            BV bvA = BVs[bv.indexA];
            float dstA = RayBVIntersect(ray, bvA); debugData.bvChecks++;
            BV bvB = BVs[bv.indexB];
            float dstB = RayBVIntersect(ray, bvB); debugData.bvChecks++;
 
            // Push the nearest BV last, to avaluate it first
            if (dstA < dstB)
            {
                if (dstB < hitInfo.dst) bvStack[stackPointer++] = bv.indexB;
                if (dstA < hitInfo.dst) bvStack[stackPointer++] = bv.indexA;
            }
            else
            {
                if (dstA < hitInfo.dst) bvStack[stackPointer++] = bv.indexA;
                if (dstB < hitInfo.dst) bvStack[stackPointer++] = bv.indexB;
            }
        }
    }
}

uint3 GetMipmapOffset(uint mipmapLayer)
{
    uint3 offset = 0;
    
    if (mipmapLayer >= 1) offset.x += TextureMM1Dims.x;

    // This can be made without a for loop!
    for (uint i = 1; i < mipmapLayer; i++) offset.y += (uint)(TextureMM1Dims.y / pow(2, i));

    return offset;
}

uint ReadFromMipmapLayer(uint3 pixelID, uint mipmapLayer)
{
    uint3 offsetPixelID = GetMipmapOffset(mipmapLayer) + pixelID;

    return SurfaceCells[offsetPixelID];
}

bool ReadBit(uint val, int bitNr)
{
    return (val & (1 << bitNr)) != 0;
}

bool IsOutsideGrid(uint3 cell, uint3 gridCellsNum)
{
    return (cell.x < 0 || cell.x >= gridCellsNum.x ||
            cell.y < 0 || cell.y >= gridCellsNum.y ||
            cell.z < 0 || cell.z >= gridCellsNum.z);
}

void EnsureNonZero(inout float val)
{
    float MIN = 0.01;
    float sign = (val > 0.0) ? 1 : -1; // sign() function can return 0 if val == 0
    val = abs(val) > MIN ? val : sign * MIN;
}

static const uint nodeStackLength = 50;
void DDA(HitInfo hitInfo, Ray ray, uint3 gridCellsNum, float3 cellSize, float3 gridMin, float3 gridMax, inout uint4 nodeStack[nodeStackLength], inout uint stackPointer, inout bool tempBool)
{
    // Ensure ray direction values are non-zero
    EnsureNonZero(ray.dir.x);
    EnsureNonZero(ray.dir.y);
    EnsureNonZero(ray.dir.z);

    // Calculate the starting cell
    int3 cell = int3(floor((ray.pos - gridMin) / cellSize));

    // Determine the step direction
    int3 step;
    step.x = (ray.dir.x > 0.0) ? 1 : -1;
    step.y = (ray.dir.y > 0.0) ? 1 : -1;
    step.z = (ray.dir.z > 0.0) ? 1 : -1;

    // Calculate the distance from the ray's position to the next cell boundary
    // The step axis for each loop iteration will be decided by what direction has the lowest ray distance
    float3 tMax;
    tMax.x = ((cell.x + (step.x > 0)) * cellSize.x + gridMin.x - ray.pos.x) / ray.dir.x; // * ray.invDir.x
    tMax.y = ((cell.y + (step.y > 0)) * cellSize.y + gridMin.y - ray.pos.y) / ray.dir.y; // * ray.invDir.y
    tMax.z = ((cell.z + (step.z > 0)) * cellSize.z + gridMin.z - ray.pos.z) / ray.dir.z; // * ray.invDir.z

    // Calculate how far to step along the ray per grid cell in each axis
    float3 tDelta;
    tDelta.x = abs(cellSize.x / ray.dir.x);
    tDelta.y = abs(cellSize.y / ray.dir.y);
    tDelta.z = abs(cellSize.z / ray.dir.z);

    // Traverse the grid
    // If the fluid settings are very wierd, the initial nodeStack setup can be very costly.
    // Therefore, a maximum iteration count is set
    const uint maxIterations = 100;
    for (uint i = 0; i < maxIterations; i++)
    {
        // Check if we are outside the grid bounds
        if (i > 0 && IsOutsideGrid(cell, gridCellsNum)) break;

        // If the current node is valid, add its child nodes to the node stack
        uint node8bitData = ReadFromMipmapLayer(cell, MipmapMaxDepth-1);
        if (node8bitData != 0)
        {
            tempBool = true;
            uint3 basePixelID = cell * 2;
            for (uint i = 0; i < 8; i++)
            {
                bool notEmpty = ReadBit(node8bitData, i);

                // Push child node to the stack if it contains leaves
                if (notEmpty)
                {
                    uint3 childPixelID = basePixelID + Offsets_2x2x2[i];
                    nodeStack[stackPointer++] = uint4(childPixelID, MipmapMaxDepth-2);
                }
            }
        }

        // Move to the next cell
        if (tMax.x < tMax.y && tMax.x < tMax.z)
        {
            tMax.x += tDelta.x;
            cell.x += step.x;
        }
        else if (tMax.y < tMax.z)
        {
            tMax.y += tDelta.y;
            cell.y += step.y;
        }
        else
        {
            tMax.z += tDelta.z;
            cell.z += step.z;
        }
    }
}

// WARNING: SUPER GARBAGE CODE. TODO: FIX THE BOUNDING VOLUME CRAP
float RayVoxelIntersect(uint3 pixelID, uint mipmapLayer, Ray ray)
{
    uint3 mipmipLayerCellsNum = TextureMM1Dims / pow(2, mipmapLayer); // TextureMM1Dims >> mipmapLayer;
    float3 min = FluidDims * (float3)pixelID / (float3)mipmipLayerCellsNum;
    float3 max = min + FluidDims / mipmipLayerCellsNum;

    BV voxelBV = InitBV();
    voxelBV.min = min;
    voxelBV.max = max;
    float dst = RayBVIntersect(ray, voxelBV);
    
    return dst;
}

// Bubble sort (replace later)
void SortAscending(inout float arr[8], inout uint3 arr2[8])
{
    for (int i = 0; i < 8; i++)
    {
        for (int j = 0; j < 7 - i; j++) // 7-i ensures we don't compare sorted elements
        {
            if (arr[j] > arr[j + 1])
            {
                // Swap arr[j] and arr[j + 1]
                float temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;

                // Swap arr2
                uint3 temp2 = arr2[j];
                arr2[j] = arr2[j + 1];
                arr2[j + 1] = temp2;
            }
        }
    }
}

void TraverseSparseVoxelGrid(inout HitInfo hitInfo, inout DebugData debugData, Ray ray)
{
    ray.pos -= FluidPos;
    // Initial fluid box intersection test
    BV fluidBV = InitBV();
    fluidBV.min = 0;
    fluidBV.max = FluidDims;
    float dst = RayBVIntersect(ray, fluidBV);
    if (dst > hitInfo.dst || dst == 1.#INF) return;

    // Record debug data (Temp)
    debugData.triChecks = 0;
    debugData.bvChecks = 0;

    // Init DDA data
    ray.pos += ray.dir * dst;
    uint3 highMipmapGridCellsNum = TextureMM1Dims / pow(2, MipmapMaxDepth-1);
    float3 highMipmapCellSize = FluidDims / highMipmapGridCellsNum;

    // Init nodeStack
    // uint4(pixelID: xyz, mipmap level: w)
    uint4 nodeStack[nodeStackLength]; // MipmapMaxDepth * 8 or something similar
    for (uint i = 0; i < nodeStackLength; i++) nodeStack[i] = uint4(0, 0, 0, 0);
    uint stackPointer = 0;
    // Use DDA to get the root nodes intersected by the ray
    bool tempBool = false;
    DDA(hitInfo, ray, highMipmapGridCellsNum, highMipmapCellSize, 0, FluidDims, nodeStack, stackPointer, tempBool);
    if (tempBool) debugData.bvChecks = 2;

    const uint maxIterations = 100;
    uint iterationCount = 0;
    while (stackPointer > 0 && iterationCount < maxIterations) 
    {   
        iterationCount++; // temp
        uint4 node = nodeStack[--stackPointer];

        bool isLeaf = node.w == 0;

        if (isLeaf)
        {
            // uint2(triStartPos, numTris)
            uint2 nodeContents = SurfaceCellsLookup[node.xyz];

            DebugData t = InitDebugData();
            TestTriangles(hitInfo, t, ray, nodeContents.x, nodeContents.x + nodeContents.y);
        }
        else
        {
            // RINT (8 bits total). Each bit corresponds to one of the children cells (true if the child contains leaves)
            uint node8bitData = ReadFromMipmapLayer(node.xyz, node.w);

            // Perform hash lookup?
            // Order the stack appends!
            // Currently without ANY CELL CHECKS
            if (node8bitData != 0)
            {
                uint3 basePixelID = node.xyz * 2;
                uint i = 0;

                // Init childPixelIDs
                uint3 childPixelIDs[8];
                for (i = 0; i < 8; i++) childPixelIDs[i] = basePixelID + Offsets_2x2x2[i];

                // Init distances
                float distances[8];
                for (i = 0; i < 8; i++) distances[i] = 1.#INF;

                // Perform ray-voxel intersection tests for each non-empty child node
                for (i = 0; i < 8; i++)
                {
                    bool notEmpty = ReadBit(node8bitData, i);

                    // Push child node to the stack if it contains leaves
                    if (notEmpty)
                    {
                        float dst = RayVoxelIntersect(childPixelIDs[i], node.w - 1, ray);

                        // Add the dst value if the voxel was hit
                        if (dst != 1.#INF) distances[i] = dst;
                    }
                }

                // Sort the child nodes by hit distance
                SortAscending(distances, childPixelIDs);

                // Append childs to nodeStack in order
                for (i = 0; i < 8; i++)
                {
                    float dst = distances[i];
                    if (dst < hitInfo.dst && dst != 1.#INF)
                    {
                        debugData.bvChecks += 2;
                        nodeStack[stackPointer++] = uint4(childPixelIDs[i], node.w - 1);
                    }
                }
            }
        }
    }
}
 
HitInfo GetRayCollision(Ray ray, inout DebugData debugData)
{
    HitInfo hitInfo = InitHitInfo();
 
    TraverseSceneBVH(hitInfo, debugData, ray);

    // Fluid mesh test
    TraverseSparseVoxelGrid(hitInfo, debugData, ray);
 
    return hitInfo;
}
 
int LightObjectReservoirSample(inout uint state)
{
    int firstIndex = randIntSpan(0, EmittingObjectsNum, state);
    float firstWeight = LightObjects[firstIndex].areaApprox;
    Reservoir reservoir = InitReservoir(firstIndex, firstWeight);
 
    for (uint i = 0; i < SceneObjectReservoirTestsNum; i++)
    {
        int candidateIndex = randIntSpan(0, EmittingObjectsNum, state); // 1 -> EmittingObjectsNum
        float candidateWeight = LightObjects[candidateIndex].areaApprox;
 
        if (weightedRand(candidateWeight, reservoir.totWeights, state))
        {
            reservoir.chosenIndex = candidateIndex;
            reservoir.chosenWeight = candidateWeight;
        }
        reservoir.totWeights += candidateWeight;
    }
 
    return reservoir.chosenIndex;
}

float GetTriArea(Triangle tri)
{
    float3 v0 = Vertices[tri.vertex0Index].pos;
    float3 v1 = Vertices[tri.vertex1Index].pos;
    float3 v2 = Vertices[tri.vertex2Index].pos;

    float3 ab = v1 - v0;
    float3 ac = v2 - v0;
    float3 crossProduct = cross(ab, ac);
    float area = length(crossProduct) * 0.5;
    return area;
}
 
int TriReservoirSample(uint startTriIndex, uint endTriIndex, inout uint state)
{
    int firstIndex = randIntSpan(startTriIndex, endTriIndex, state);
    float firstWeight = Triangles[firstIndex].area;
    Reservoir reservoir = InitReservoir(firstIndex, firstWeight);
 
    for (uint i = 0; i < TriReservoirTestsNum; i++)
    {
        int candidateIndex = randIntSpan(startTriIndex, endTriIndex, state);
        float candidateWeight = Triangles[candidateIndex].area;
 
        if (weightedRand(candidateWeight, reservoir.totWeights, state))
        {
            reservoir.chosenIndex = candidateIndex;
            reservoir.chosenWeight = candidateWeight;
        }
        reservoir.totWeights += candidateWeight;
    }
 
    return reservoir.chosenIndex;
}

// (weight, BRDF)
float2 GenerateCandidateWeight(float sqrDst, float hitAngleDot, float3 incomingDir, float3 outgoingDir, float3 hitNormal, float metallicity, float roughness, float brightness)
{
    float weight = brightness * hitAngleDot / sqrDst;
    float brdf = 1.0;
    #if BRDF
        brdf = GetBRDF(incomingDir, outgoingDir, hitNormal, metallicity, roughness);
        weight *= brdf;
    #endif
    return float2(weight, brdf);
}

float3 GetRandWorldPointTri(Triangle tri, float4x4 localToWorldMatrix, inout uint state)
{
    float3 v0 = Vertices[tri.vertex0Index].pos;
    float3 v1 = Vertices[tri.vertex1Index].pos;
    float3 v2 = Vertices[tri.vertex2Index].pos;

    float r1 = randNormalized(state);
    float r2 = randNormalized(state);

    // Ensure the point lies within the tri
    if (r1 + r2 > 1.0)
    {
        r1 = 1.0 - r1;
        r2 = 1.0 - r2;
    }

    float3 localPoint = v0 * (1.0 - r1 - r2) + v1 * r1 + v2 * r2;

    float3 worldPoint = mul(localToWorldMatrix, float4(localPoint, 1.0)).xyz;

    return worldPoint;
}
 
void GenerateCandidatesDL(HitInfo hitInfo, uint pixelIndex, inout uint state)
{
    // Weighted light object Sample
    uint lightObjectIndex = LightObjectReservoirSample(state);
    LightObject lightObject = LightObjects[lightObjectIndex];
    uint startTriIndex = lightObject.triStart;
    uint endTriIndex = lightObject.triStart + lightObject.totTris;

    // Weighted tri Sample
    uint triIndex = TriReservoirSample(startTriIndex, endTriIndex, state);
    Triangle tri = Triangles[triIndex];
    float3 worldPoint = GetRandWorldPointTri(tri, lightObject.localToWorldMatrix, state);

    float3 dst = worldPoint - hitInfo.hitPoint;
    float3 dir = normalize(dst);

    // Validate direction
    if (dot(hitInfo.normal, dir) < 0)
    {
        // If direction is invalid, abandon the current candidate by assigning an empty reservoir
        Candidates[pixelIndex] = InitCandidateReservoir();
        return;
    }

    float3 worldNormal = normalize(mul(lightObject.localToWorldMatrix, float4(tri.localNormal, 0)).xyz);

    float hitAngleDot = max(dot(worldNormal, dir), 0);
    float sqrDst = dot2(dst);

    Material2 material = Materials[hitInfo.materialIndex];
    float metallicity = material.metallicity == -1 ? SampleTexture(hitInfo.uv, material.metallicityTexLoc, material.metallicityTexDims, TextureAtlas).x : material.metallicity;
    float roughness = material.roughness == -1 ? SampleTexture(hitInfo.uv, material.roughnessTexLoc, material.roughnessTexDims, TextureAtlas).x : material.roughness;

    float2 candidateWeightAndBRDF = GenerateCandidateWeight(sqrDst, hitAngleDot, hitInfo.incomingDir, dir, hitInfo.normal, metallicity, roughness, lightObject.brightness);

    // Visibility reuse
    // Expensive due to the need for casting a ray, but removes any and all visibility noise from the end result
    #if VIS_REUSE
        Ray shadowRay = InitRay(hitInfo.hitPoint, dir);
        DebugData t = InitDebugData();

        // Traverse the scene to validate the candidate
        // Then discard the candidate from further use if the target is occluded
        HitInfo shadowHitInfo = GetRayCollision(shadowRay, t);
        if (Materials[shadowHitInfo.materialIndex].brightness == 0) candidateWeightAndBRDF.x = 0;
    #endif

    CandidateReservoir candidateReservoir = InitCandidateReservoir(dir, hitInfo.hitPoint, hitInfo.normal, candidateWeightAndBRDF.y, candidateWeightAndBRDF.x, candidateWeightAndBRDF.x, 1);
    Candidates[pixelIndex] = candidateReservoir;
}
 
uint GetPixelIndex(uint2 threadID)
{
    return Resolution.x * threadID.y + threadID.x;
}

float3 GetFocalPos(float2 uv)
{
    float focalPosX = (uv.x - 0.5) * 2.0 * ViewSpaceDims.x;
    float focalPosY = (uv.y - 0.5) * 2.0 * ViewSpaceDims.y;
    float3 focalPos = float3(focalPosX, focalPosY, 1) * FocalPlaneFactor;
    float3 worldFocalPos = mul(CameraTransform, focalPos) + WorldSpaceCameraPos;

    return worldFocalPos;
}

float2 GetLastUV(float3 worldFocalPos)
{
    // Inverse of GetFocalPos(), and specialized for last frame camera data
    float3 focalPos = worldFocalPos - LastWorldSpaceCameraPos;
    float3 cameraFocalPos = mul(LastCameraTransformInverse, focalPos);
    float3 ndcFocalPos = cameraFocalPos / FocalPlaneFactor;
    float uvX = (ndcFocalPos.x / (2.0 * ViewSpaceDims.x)) + 0.5;
    float uvY = (ndcFocalPos.y / (2.0 * ViewSpaceDims.y)) + 0.5;

    return clamp(float2(uvX, uvY), 0.0, 1.0);
}
 
[numthreads(TN_RT,TN_RT,1)]
void InitialTrace (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)Resolution.x || id.y >= (uint)Resolution.y) return;
    DebugData debugData = InitDebugData();
    uint state = id.y * Resolution.x + id.x + FrameRand;
 
    // Calculate focal plane world pos for the given pixel
    float2 uv = float2(id.xy) / float2(Resolution);
    float3 worldFocalPos = GetFocalPos(uv);
 
    // Trace ray(s) through the scene
    uint pixelIndex = GetPixelIndex(id.xy);
 
    // Ray setup
    Ray ray;
    float3 jitter = mul(CameraTransform, float3(randPointInCircle(state) * DefocusStrength, 0));
    ray.pos = WorldSpaceCameraPos + jitter * FocalPlaneFactor;
    ray.dir = normalize(worldFocalPos - ray.pos);
    ray.invDir = 1 / ray.dir;
 
    // Cast first ray
    HitInfo hitInfo = GetRayCollision(ray, debugData);
    bool didHit = hitInfo.dst != 1.#INF;
    hitInfo.incomingDir = ray.dir;

    Material2 material = Materials[hitInfo.materialIndex];
    float bump = material.bump == -1 ? SampleTexture(hitInfo.uv, material.bumpTexLoc, material.bumpTexDims, TextureAtlas).x : material.bump;
    hitInfo.hitPoint -= hitInfo.incomingDir * bump;
 
    // Generate a ray bounce direction candidate
    if (didHit) GenerateCandidatesDL(hitInfo, pixelIndex, state);
 
    // Save ray hit info data
    HitInfos[pixelIndex] = hitInfo;
 
    // Record data to textures
    bool badMaxBVHDepth = MaxBVHDepth > MAX_BVH_DEPTH;
    
    DebugOverlay[id.xy] = float4(debugData.triChecks / (float)DebugDataMaxValues.x, debugData.bvChecks / (float)DebugDataMaxValues.y, badMaxBVHDepth, 0);
    
    DepthBuffer[id.xy] = hitInfo.dst;
    NormalsBuffer[id.xy] = (hitInfo.normal + 1) * 0.5; // normalized to fit in a render texture
 
    float3 firstHit = didHit ? hitInfo.hitPoint : float3(0, 0, 0);
    if (FrameCount % 2 == 0) RayHitPointsA[id.xy] = firstHit;
    else RayHitPointsB[id.xy] = firstHit;
}
 
// ---Kernel "SpatialReusePass": ---

CandidateReservoir SpatialCandidateReservoirSample(uint pixelBaseIndex, int2 threadID, inout uint state)
{
    CandidateReservoir spatialReservoir = InitCandidateReservoir();
 
    CandidateReservoir baseReservoir;
    if (ReuseBufferCycle) baseReservoir = Candidates[pixelBaseIndex];
    else baseReservoir = CandidatesB[pixelBaseIndex];

    spatialReservoir = baseReservoir;

    for (uint i = 0; i < TemporalCandidatesNum; i++)
    {
        int2 randOffset = float2(randIntSpan(-MaxOffset, MaxOffset, state), randIntSpan(-MaxOffset, MaxOffset, state));
        int2 offsetID = threadID + randOffset;
        if (offsetID.x >= Resolution.x || offsetID.y >= Resolution.y || any(offsetID) < 0 || DepthBuffer[offsetID] == 1.#INF) continue;

        // Get candidate weight
        uint pixelIndex = GetPixelIndex(offsetID);

        CandidateReservoir candidateReservoir;
        if (ReuseBufferCycle) candidateReservoir = Candidates[pixelIndex];
        else candidateReservoir = CandidatesB[pixelIndex];
        if (all(candidateReservoir.dir) == 0) continue;

        float hitPointDiff = length(baseReservoir.hitPoint - candidateReservoir.hitPoint);
        float normalDiffDeg = angleBetweenNormals(baseReservoir.normal, candidateReservoir.normal);
        if (hitPointDiff > SpatialHitPointDiffThreshold || normalDiffDeg > SpatialNormalsAngleThreshold || abs(spatialReservoir.brdf - candidateReservoir.brdf) > SpatialBRDFThreshold) continue;

        if (weightedRand(candidateReservoir.chosenWeight, spatialReservoir.totWeights, state))
        {
            spatialReservoir.dir = candidateReservoir.dir;
            spatialReservoir.chosenWeight = candidateReservoir.chosenWeight;
            spatialReservoir.hitPoint = candidateReservoir.hitPoint;
            spatialReservoir.normal = candidateReservoir.normal;
            spatialReservoir.brdf = candidateReservoir.brdf;
        }

        spatialReservoir.totWeights += candidateReservoir.totWeights;
        spatialReservoir.totCandidates += candidateReservoir.totCandidates;
    }
 
    return spatialReservoir;
}
 
[numthreads(TN_RT,TN_RT,1)]
void SpatialReusePass (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)Resolution.x || id.y >= (uint)Resolution.y || DepthBuffer[id.xy] == 1.#INF) return;
    uint state = id.y * Resolution.x + id.x + FrameRand;
 
    uint pixelIndex = GetPixelIndex(id.xy);
 
    // Spatial reservoir sampling for each ray
    CandidateReservoir newCandidateReservoir = SpatialCandidateReservoirSample(pixelIndex, id.xy, state);

    if (ReuseBufferCycle) CandidatesB[pixelIndex] = newCandidateReservoir;
    else Candidates[pixelIndex] = newCandidateReservoir;
}
 
// ---Kernel "TransferToOriginal": ---
 
[numthreads(TN_RT,TN_RT,1)]
void TransferToOriginal (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)Resolution.x || id.y >= (uint)Resolution.y || DepthBuffer[id.xy] == 1.#INF) return;
 
    uint pixelIndex = GetPixelIndex(id.xy);
    Candidates[pixelIndex] = CandidatesB[pixelIndex];
}
 
// --- Kernel "TemporalReuse": ---
 
[numthreads(TN_RT,TN_RT,1)]
void TemporalReuse (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)Resolution.x || id.y >= (uint)Resolution.y || DepthBuffer[id.xy] == 1.#INF || FrameCount == 0) return;
    uint state = id.y * Resolution.x + id.x + FrameRand;
 
    // This frame pixel index
    uint pixelIndex = GetPixelIndex(id.xy);

    // Last Frame pixel index
    float2 uv = float2(id.xy) / float2(Resolution);
    float3 worldFocalPos = GetFocalPos(uv);
    float2 lastFrameUV = GetLastUV(worldFocalPos);
    int2 offsetID = int2(lastFrameUV * float2(Resolution));
    if (length(uv - lastFrameUV) > TemporalPrecisionThreshold)
    {
        TemporalFrameBuffer[pixelIndex] = Candidates[pixelIndex];
        return;
    }
    else offsetID = id.xy;

    uint lastFramePixelIndex = GetPixelIndex(offsetID);
 
    // --- Temporal reuse ---

    // Evaluate pixel frame-to-frame movement
    // Temp. Replace with a more sophisticated function.
    float pixelHitPointMovement = length(RayHitPointsA[id.xy] - RayHitPointsB[id.xy]);

    CandidateReservoir thisFrameReservoir = Candidates[pixelIndex];

    if (pixelHitPointMovement <= PixelMovementThreshold)
    {
        CandidateReservoir lastFrameCandidate = TemporalFrameBuffer[lastFramePixelIndex];

        float adjustedThisFrameWeight = thisFrameReservoir.totWeights * (1.0 - TemporalReuseWeight);
        float adjustedLastFrameWeight = lastFrameCandidate.totWeights * TemporalReuseWeight;
        float totWeights = adjustedThisFrameWeight + adjustedLastFrameWeight;
        
        if (weightedRand(adjustedLastFrameWeight, totWeights, state))
        {
            thisFrameReservoir.dir = lastFrameCandidate.dir;
            thisFrameReservoir.chosenWeight = lastFrameCandidate.chosenWeight;
            thisFrameReservoir.hitPoint = lastFrameCandidate.hitPoint;
        }
        
        // Average the weights and candidates with respect to TemporalReuseWeight
        thisFrameReservoir.totWeights = avg(thisFrameReservoir.totWeights * (1.0 - TemporalReuseWeight),
                                            lastFrameCandidate.totWeights * TemporalReuseWeight);
        thisFrameReservoir.totCandidates = avg(thisFrameReservoir.totCandidates * (1.0 - TemporalReuseWeight),
                                                lastFrameCandidate.totCandidates * TemporalReuseWeight);
    }
    
    Candidates[pixelIndex] = thisFrameReservoir;
    TemporalFrameBuffer[pixelIndex] = thisFrameReservoir;
}
 
// --- Kernel "TraceRays": ---
 
void UpdateCandidateWeight(float sqrDst, float hitAngleDot, float3 incomingDir, float3 outgoingDir, float3 hitNormal, float metallicity, float roughness, float brightness, uint pixelIndex)
{
    // Calculate new weight and BRDF
    bool validCandidate = brightness > 0;
    if (!validCandidate) return;
    float2 newWeightAndBRDF = GenerateCandidateWeight(sqrDst, hitAngleDot, incomingDir, outgoingDir, hitNormal, metallicity, roughness, brightness);

    // Apply new weight and BRDF
    TemporalFrameBuffer[pixelIndex].chosenWeight = newWeightAndBRDF.x;
    TemporalFrameBuffer[pixelIndex].brdf = newWeightAndBRDF.y;

    return;
}

Material2 GetMaterial(HitInfo hitInfo)
{
    Material2 material = InitMaterial();
    if (hitInfo.dst != 1.#INF) material = Materials[hitInfo.materialIndex];
    return material;
}

bool IsInvalidCandidate(uint bounceCount, Material2 material, HitInfo hitInfo, Ray ray)
{
    return (bounceCount == 1 && material.brightness <= 0) || 
           (bounceCount == 0 && dot(hitInfo.normal, ray.dir) < 0) || 
           (hitInfo.dst == 1.#INF);
}

float3 GetScatterDirection(HitInfo hitInfo, inout uint state)
{
    return normalize(hitInfo.normal + randPointOnUnitSphere(state));
}

float3 GetRayDirection(HitInfo hitInfo, inout uint state)
{
    float3 newDir = GetScatterDirection(hitInfo, state);

    // Validate ray direction
    float hitAngleDot = dot(hitInfo.normal, newDir);
    if (hitAngleDot < 0) newDir = -newDir;

    return newDir;
}

float3 GetEmittedLight(Material2 material, HitInfo hitInfo)
{
    float3 sampleCol = all(material.col == -1) ? 
                        SampleTexture(hitInfo.uv, material.colTexLoc, material.colTexDims, TextureAtlas) : 
                        material.col;
    return sampleCol * material.brightness / sqr(hitInfo.dst);
}

float3 GetRayColFactor(Ray ray, HitInfo hitInfo, Material2 material, float3 incomingDir, float metallicity, float roughness, bool isSpecularBounce)
{
    float3 rayColFactor = all(material.col == -1) ? 
                        SampleTexture(hitInfo.uv, material.colTexLoc, material.colTexDims, TextureAtlas) : 
                        material.col;

    #if BRDF
        rayColFactor *= GetBRDF(incomingDir, ray.dir, hitInfo.normal, metallicity, roughness);
    #endif

    return rayColFactor;
}

TraceInfo Trace(Ray ray, HitInfo hitInfo, uint pixelIndex, inout DebugData debugData, inout uint state)
{
    TraceInfo traceInfo;
    traceInfo.totTravelDst = 0;
    traceInfo.rayColor = dot(hitInfo.normal, ray.dir);
    traceInfo.directLight = float3(0, 0, 0);
    traceInfo.indirectLight = float3(0, 0, 0);
    float3 incomingDir = hitInfo.incomingDir;

    for (uint bounceCount = 0; bounceCount <= MaxBounceCount; bounceCount++) {
        if (hitInfo.dst == 1.#INF) break;

        Material2 material = GetMaterial(hitInfo);

        // Validate candidate and reset if invalid
        if (IsInvalidCandidate(bounceCount, material, hitInfo, ray)) Candidates[pixelIndex] = InitCandidateReservoir();

        // Calculate new ray direction for bounces beyond the first
        float metallicity = material.metallicity == -1 ? SampleTexture(hitInfo.uv, material.metallicityTexLoc, material.metallicityTexDims, TextureAtlas).x : material.metallicity;
        float roughness = material.roughness == -1 ? SampleTexture(hitInfo.uv, material.roughnessTexLoc, material.roughnessTexDims, TextureAtlas).x : material.roughness;

        if (bounceCount != 0)
        {
            incomingDir = ray.dir;
            bool isSpecularBounce = ScatterProbability < randNormalized(state);
            ray.dir = GetRayDirection(hitInfo, state);

            // Weight recalculations
            // Update candidate weight on first bounce
            #if WEIGHT_RECALC
                if (bounceCount == 1) UpdateCandidateWeight(sqr(hitInfo.dst), max(dot(hitInfo.normal, ray.dir), 0), incomingDir, ray.dir, hitInfo.normal, metallicity, roughness, material.brightness, pixelIndex);
            #endif
        }

        // Update trace information
        float3 emittedLight = GetEmittedLight(material, hitInfo);
        traceInfo.rayColor *= GetRayColFactor(ray, hitInfo, material, incomingDir, metallicity, roughness, true);
        traceInfo.totTravelDst += hitInfo.dst;

        if (bounceCount == 0) traceInfo.directLight += emittedLight * traceInfo.rayColor;
        else traceInfo.indirectLight += emittedLight * traceInfo.rayColor;

        // Recast ray for the next bounce
        if (bounceCount != MaxBounceCount) hitInfo = GetRayCollision(ray, debugData);
    }

    return traceInfo;
}

[numthreads(TN_RT,TN_RT,1)]
void TraceRays (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)Resolution.x || id.y >= (uint)Resolution.y) return;
    DebugData debugData = InitDebugData(); // Debug data never gets recorded for this kernel
    uint state = id.y * Resolution.x + id.x + FrameRand;
 
    uint pixelIndex = GetPixelIndex(id.xy);

    // Retrieve stored hitInfo data
    HitInfo hitInfo = HitInfos[id.y * Resolution.x + id.x];
 
    // --- Trace the ray through the scene ---

    // Get a ray direction from the current candidates
    CandidateReservoir candidateReservoir = Candidates[pixelIndex];

    // Return no color if initial ray trace missed
    if (hitInfo.dst == 1.#INF)
    {
        float3 col = SampleEnvironmentMap(hitInfo.incomingDir);
        Result[id.xy] = float4(col.x, col.y, col.z, 0);
        return;
    }
    // Return the emitted light of the first hit object if no further ray direction candidates are found
    else if (all(candidateReservoir.dir) == 0 || dot(hitInfo.normal, candidateReservoir.dir) < 0)
    {
        Material2 material = Materials[hitInfo.materialIndex];

        // Calculate new traceInfo values
        float3 sampleCol = all(material.col == -1) ? SampleTexture(hitInfo.uv, material.colTexLoc, material.colTexDims, TextureAtlas) : material.col;
        float3 emittedLight = sampleCol * material.brightness / sqr(hitInfo.dst);
        float3 col = emittedLight;

        Result[id.xy] = float4(col, 0);
        return;
    }

    // Ray setup
    Ray ray;
    ray.pos = hitInfo.hitPoint;
    ray.dir = candidateReservoir.dir;
    ray.invDir = 1 / ray.dir;

    // Trace ray
    TraceInfo traceInfo = Trace(ray, hitInfo, pixelIndex, debugData, state);

    // Record traceInfo
    float avgCandidateWeight = candidateReservoir.totWeights / candidateReservoir.totCandidates;
    float correctionWeight = avgCandidateWeight / candidateReservoir.chosenWeight;
    traceInfo.indirectLight *= correctionWeight;
    
    float3 combinedLight = traceInfo.directLight + (traceInfo.indirectLight / sqr(traceInfo.totTravelDst)); // Compensation for candidate weight?

    // Record ray tracer result
    Result[id.xy] = float4(combinedLight, 0);
}