#pragma kernel AccumulateFrames // 0
#pragma kernel RenderNoiseTextures // 1

#include "RendererResources.hlsl"

// Per frame
const int FrameCount;

// Noise settings
const uint3 NoiseResolution;
const float NoisePixelSize;

RWTexture2D<float4> Result;
RWTexture2D<float4> AccumulatedResult;

RWTexture3D<float> NoiseA;
RWTexture3D<float> NoiseB;

[numthreads(TN_PP,TN_PP,1)]
void AccumulateFrames (uint3 id : SV_DispatchThreadID)
{
    float3 colNew = Result[id.xy].xyz;
    float3 colPrev = AccumulatedResult[id.xy].xyz;
    float weight = 1.0 / (FrameCount + 1);
    float3 accumulatedCol = saturate(colPrev * (1 - weight) + colNew * weight);

    AccumulatedResult[id.xy] = float4(accumulatedCol.x, accumulatedCol.y, accumulatedCol.z, 0);
}

[numthreads(TN_PP,TN_PP,1)]
void RenderNoiseTextures (uint3 id : SV_DispatchThreadID)
{
    float pS = NoisePixelSize; // pixelSize
    pS = max(pS, 0.1);
    uint2 scaledID = id.xy % pS + id.xy / pS;

    uint2 idW = scaledID % NoiseResolution.xy;
    if (idW.x == 0 && id.x != 0) return;

    float result;
    result = scaledID.x > NoiseResolution.x
    ? NoiseB[uint3(idW.x % pS + idW.x / pS, idW.y % pS + idW.y / pS, (uint)FrameCount % NoiseResolution.z)]
    : NoiseA[uint3(idW.x % pS + idW.x / pS, idW.y % pS + idW.y / pS, (uint)FrameCount % NoiseResolution.z)];

    if (scaledID.x < 2*NoiseResolution.x && scaledID.y < NoiseResolution.y && result > 0.0)
    {
        Result[id.xy] = float4(result, result, result, 0);
        return;
    }
    // Override the whole rendered image?
    // Result[id.xy] = float4(0, 0, 0, 0);
}